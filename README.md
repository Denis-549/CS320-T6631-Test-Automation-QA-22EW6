# CS320-T6631-Test-Automation-QA-22EW6
 CS320-Projects
How can I ensure that my code, program, or software is functional and secure?

Learning about the process and importance of testing be it by way of automated testing and/or via QA, has given me a brand new perspective on how code security and functionality works. Testing is extremely important in ensuring code, program, or software security. Having an unbiased mindset, adhering to requirements, appreciating the complexity and interrelationship of code especially during testing all should be part of my effort to ensure code/program/software functionality and security. The implementation of secure code practices such as automating error handling and logging, input validation and output encoding, along with creating (Junit) test cases in my (java) IDE, and then running those test cases in a project, should be part of the guiding principles on how I approach software testing and/or development. Additionally, Identifying the right testing techniques and implementing them as often as required and especially when oneâ€™s needed also helps in ensuring that the overall quality of my work meets and/or exceeds acceptable standards. 

How do I interpret user needs and incorporate them into a program?

I think it is important as a developer to first, always look at user needs from the perspective of an end user or a real-life user as opposed to that of a software development practitioner. Requirements simply represent the needs of the user therefore making sure those needs are fully understood and applied during each phase (development/testing) of the development process will help to make sure that my work aligns with requirements as per the user. Implementing appropriate testing techniques, also plays into ensuring user needs are properly interpreted and incorporated into a program. 

How do I approach designing software?

My first step will be to seek to fully understand the ask/goal/overarching objective followed by me determining my role in the project. I think that Software design involves much more that goes beyond understanding the function(s) and/or object orientation of it. I think understanding the breakdown of the software, where by for example each sub-system as system is treated as a system on its own that then gets decomposed further, such that the lowest level of the system In a somewhat top-down hierarchy is eventually achieved is key. In this approach the software begins with a generalized model of the system which then will continue to be defined (by specific parts) until the smallest portion of it is complete.
